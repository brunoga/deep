// Code generated by deep-gen. DO NOT EDIT.
package v5

import (
	"fmt"
	"regexp"
	"strings"
)

// ApplyOperation applies a single operation to User efficiently.
func (t *User) ApplyOperation(op Operation) (bool, error) {
	if op.If != nil {
		ok, err := t.evaluateCondition(*op.If)
		if err != nil || !ok {
			return true, err
		}
	}
	if op.Unless != nil {
		ok, err := t.evaluateCondition(*op.Unless)
		if err == nil && ok {
			return true, nil
		}
	}

	if op.Path == "" || op.Path == "/" {
		if v, ok := op.New.(User); ok {
			*t = v
			return true, nil
		}
		if m, ok := op.New.(map[string]any); ok {
			for k, v := range m {
				t.ApplyOperation(Operation{Kind: op.Kind, Path: "/" + k, New: v})
			}
			return true, nil
		}
	}

	switch op.Path {
	case "/id", "/ID":
		if op.Kind == OpLog {
			fmt.Printf("DEEP LOG: %v (at %s, field value: %v)\n", op.New, op.Path, t.ID)
			return true, nil
		}
		if op.Kind == OpReplace && op.Strict {
			if t.ID != op.Old.(int) {
				return true, fmt.Errorf("strict check failed at %s: expected %v, got %v", op.Path, op.Old, t.ID)
			}
		}
		if v, ok := op.New.(int); ok {
			t.ID = v
			return true, nil
		}
		if f, ok := op.New.(float64); ok {
			t.ID = int(f)
			return true, nil
		}
	case "/full_name", "/Name":
		if op.Kind == OpLog {
			fmt.Printf("DEEP LOG: %v (at %s, field value: %v)\n", op.New, op.Path, t.Name)
			return true, nil
		}
		if op.Kind == OpReplace && op.Strict {
			if t.Name != op.Old.(string) {
				return true, fmt.Errorf("strict check failed at %s: expected %v, got %v", op.Path, op.Old, t.Name)
			}
		}
		if v, ok := op.New.(string); ok {
			t.Name = v
			return true, nil
		}
	case "/info", "/Info":
		if op.Kind == OpLog {
			fmt.Printf("DEEP LOG: %v (at %s, field value: %v)\n", op.New, op.Path, t.Info)
			return true, nil
		}
		if op.Kind == OpReplace && op.Strict {
			// Complex strict check skipped in prototype
		}
		if v, ok := op.New.(Detail); ok {
			t.Info = v
			return true, nil
		}
	case "/roles", "/Roles":
		if op.Kind == OpLog {
			fmt.Printf("DEEP LOG: %v (at %s, field value: %v)\n", op.New, op.Path, t.Roles)
			return true, nil
		}
		if op.Kind == OpReplace && op.Strict {
			// Complex strict check skipped in prototype
		}
		if v, ok := op.New.([]string); ok {
			t.Roles = v
			return true, nil
		}
	case "/score", "/Score":
		if op.Kind == OpLog {
			fmt.Printf("DEEP LOG: %v (at %s, field value: %v)\n", op.New, op.Path, t.Score)
			return true, nil
		}
		if op.Kind == OpReplace && op.Strict {
			// Complex strict check skipped in prototype
		}
		if v, ok := op.New.(map[string]int); ok {
			t.Score = v
			return true, nil
		}
	case "/bio", "/Bio":
		if op.Kind == OpLog {
			fmt.Printf("DEEP LOG: %v (at %s, field value: %v)\n", op.New, op.Path, t.Bio)
			return true, nil
		}
		if op.Kind == OpReplace && op.Strict {
			// Complex strict check skipped in prototype
		}
		if v, ok := op.New.(Text); ok {
			t.Bio = v
			return true, nil
		}
	case "/age":
		if op.Kind == OpLog {
			fmt.Printf("DEEP LOG: %v (at %s, field value: %v)\n", op.New, op.Path, t.age)
			return true, nil
		}
		if op.Kind == OpReplace && op.Strict {
			if t.age != op.Old.(int) {
				return true, fmt.Errorf("strict check failed at %s: expected %v, got %v", op.Path, op.Old, t.age)
			}
		}
		if v, ok := op.New.(int); ok {
			t.age = v
			return true, nil
		}
		if f, ok := op.New.(float64); ok {
			t.age = int(f)
			return true, nil
		}
	default:
		if strings.HasPrefix(op.Path, "/info/") {
			if (&t.Info) != nil {
				op.Path = op.Path[len("/info/")-1:]
				return (&t.Info).ApplyOperation(op)
			}
		}
		if strings.HasPrefix(op.Path, "/score/") {
			parts := strings.Split(op.Path[len("/score/"):], "/")
			key := parts[0]
			if op.Kind == OpRemove {
				delete(t.Score, key)
				return true, nil
			} else {
				if t.Score == nil {
					t.Score = make(map[string]int)
				}
				if v, ok := op.New.(int); ok {
					t.Score[key] = v
					return true, nil
				}
			}
		}
	}
	return false, nil
}

// Diff compares t with other and returns a Patch.
func (t *User) Diff(other *User) Patch[User] {
	p := NewPatch[User]()
	if t.ID != other.ID {
		p.Operations = append(p.Operations, Operation{
			Kind: OpReplace,
			Path: "/id",
			Old:  t.ID,
			New:  other.ID,
		})
	}
	if t.Name != other.Name {
		p.Operations = append(p.Operations, Operation{
			Kind: OpReplace,
			Path: "/full_name",
			Old:  t.Name,
			New:  other.Name,
		})
	}
	if (&t.Info) != nil && &other.Info != nil {
		subInfo := (&t.Info).Diff(&other.Info)
		for _, op := range subInfo.Operations {
			if op.Path == "" || op.Path == "/" {
				op.Path = "/info"
			} else {
				op.Path = "/info" + op.Path
			}
			p.Operations = append(p.Operations, op)
		}
	}
	if len(t.Roles) != len(other.Roles) {
		p.Operations = append(p.Operations, Operation{
			Kind: OpReplace,
			Path: "/roles",
			Old:  t.Roles,
			New:  other.Roles,
		})
	} else {
		for i := range t.Roles {
			if t.Roles[i] != other.Roles[i] {
				p.Operations = append(p.Operations, Operation{
					Kind: OpReplace,
					Path: fmt.Sprintf("/roles/%d", i),
					Old:  t.Roles[i],
					New:  other.Roles[i],
				})
			}
		}
	}
	if other.Score != nil {
		for k, v := range other.Score {
			if t.Score == nil {
				p.Operations = append(p.Operations, Operation{
					Kind: OpReplace,
					Path: fmt.Sprintf("/score/%v", k),
					New:  v,
				})
				continue
			}
			if oldV, ok := t.Score[k]; !ok || v != oldV {
				kind := OpReplace
				if !ok {
					kind = OpAdd
				}
				p.Operations = append(p.Operations, Operation{
					Kind: kind,
					Path: fmt.Sprintf("/score/%v", k),
					Old:  oldV,
					New:  v,
				})
			}
		}
	}
	if t.Score != nil {
		for k, v := range t.Score {
			if other.Score == nil || !contains(other.Score, k) {
				p.Operations = append(p.Operations, Operation{
					Kind: OpRemove,
					Path: fmt.Sprintf("/score/%v", k),
					Old:  v,
				})
			}
		}
	}
	if (&t.Bio) != nil && other.Bio != nil {
		subBio := (&t.Bio).Diff(other.Bio)
		for _, op := range subBio.Operations {
			if op.Path == "" || op.Path == "/" {
				op.Path = "/bio"
			} else {
				op.Path = "/bio" + op.Path
			}
			p.Operations = append(p.Operations, op)
		}
	}
	if t.age != other.age {
		p.Operations = append(p.Operations, Operation{
			Kind: OpReplace,
			Path: "/age",
			Old:  t.age,
			New:  other.age,
		})
	}
	return p
}

func (t *User) evaluateCondition(c Condition) (bool, error) {
	switch c.Op {
	case "and":
		for _, sub := range c.Apply {
			ok, err := t.evaluateCondition(*sub)
			if err != nil || !ok {
				return false, err
			}
		}
		return true, nil
	case "or":
		for _, sub := range c.Apply {
			ok, err := t.evaluateCondition(*sub)
			if err == nil && ok {
				return true, nil
			}
		}
		return false, nil
	case "not":
		if len(c.Apply) > 0 {
			ok, err := t.evaluateCondition(*c.Apply[0])
			if err != nil {
				return false, err
			}
			return !ok, nil
		}
		return true, nil
	}

	switch c.Path {
	case "/id", "/ID":
		switch c.Op {
		case "==":
			return t.ID == c.Value.(int), nil
		case "!=":
			return t.ID != c.Value.(int), nil
		case "log":
			fmt.Printf("DEEP LOG CONDITION: %v (at %s, value: %v)\n", c.Value, c.Path, t.ID)
			return true, nil
		case "matches":
			return regexp.MatchString(c.Value.(string), fmt.Sprintf("%v", t.ID))
		case "type":
			return CheckType(t.ID, c.Value.(string)), nil
		}
	case "/full_name", "/Name":
		switch c.Op {
		case "==":
			return t.Name == c.Value.(string), nil
		case "!=":
			return t.Name != c.Value.(string), nil
		case "log":
			fmt.Printf("DEEP LOG CONDITION: %v (at %s, value: %v)\n", c.Value, c.Path, t.Name)
			return true, nil
		case "matches":
			return regexp.MatchString(c.Value.(string), fmt.Sprintf("%v", t.Name))
		case "type":
			return CheckType(t.Name, c.Value.(string)), nil
		}
	case "/age":
		switch c.Op {
		case "==":
			return t.age == c.Value.(int), nil
		case "!=":
			return t.age != c.Value.(int), nil
		case "log":
			fmt.Printf("DEEP LOG CONDITION: %v (at %s, value: %v)\n", c.Value, c.Path, t.age)
			return true, nil
		case "matches":
			return regexp.MatchString(c.Value.(string), fmt.Sprintf("%v", t.age))
		case "type":
			return CheckType(t.age, c.Value.(string)), nil
		}
	}
	return false, fmt.Errorf("unsupported condition path or op: %s", c.Path)
}

// Equal returns true if t and other are deeply equal.
func (t *User) Equal(other *User) bool {
	if t.ID != other.ID {
		return false
	}
	if t.Name != other.Name {
		return false
	}
	if ((&t.Info) == nil) != ((&other.Info) == nil) {
		return false
	}
	if (&t.Info) != nil && !(&t.Info).Equal((&other.Info)) {
		return false
	}
	if len(t.Roles) != len(other.Roles) {
		return false
	}
	if len(t.Score) != len(other.Score) {
		return false
	}
	if len(t.Bio) != len(other.Bio) {
		return false
	}
	for i := range t.Bio {
		if t.Bio[i] != other.Bio[i] {
			return false
		}
	}
	if t.age != other.age {
		return false
	}
	return true
}

// Copy returns a deep copy of t.
func (t *User) Copy() *User {
	res := &User{
		ID:    t.ID,
		Name:  t.Name,
		Roles: append([]string(nil), t.Roles...),
		Bio:   append(Text(nil), t.Bio...),
		age:   t.age,
	}
	if (&t.Info) != nil {
		res.Info = *(&t.Info).Copy()
	}
	if t.Score != nil {
		res.Score = make(map[string]int)
		for k, v := range t.Score {
			res.Score[k] = v
		}
	}
	return res
}

// ApplyOperation applies a single operation to Detail efficiently.
func (t *Detail) ApplyOperation(op Operation) (bool, error) {
	if op.If != nil {
		ok, err := t.evaluateCondition(*op.If)
		if err != nil || !ok {
			return true, err
		}
	}
	if op.Unless != nil {
		ok, err := t.evaluateCondition(*op.Unless)
		if err == nil && ok {
			return true, nil
		}
	}

	if op.Path == "" || op.Path == "/" {
		if v, ok := op.New.(Detail); ok {
			*t = v
			return true, nil
		}
		if m, ok := op.New.(map[string]any); ok {
			for k, v := range m {
				t.ApplyOperation(Operation{Kind: op.Kind, Path: "/" + k, New: v})
			}
			return true, nil
		}
	}

	switch op.Path {
	case "/Age":
		if op.Kind == OpLog {
			fmt.Printf("DEEP LOG: %v (at %s, field value: %v)\n", op.New, op.Path, t.Age)
			return true, nil
		}
		if op.Kind == OpReplace && op.Strict {
			if t.Age != op.Old.(int) {
				return true, fmt.Errorf("strict check failed at %s: expected %v, got %v", op.Path, op.Old, t.Age)
			}
		}
		if v, ok := op.New.(int); ok {
			t.Age = v
			return true, nil
		}
		if f, ok := op.New.(float64); ok {
			t.Age = int(f)
			return true, nil
		}
	case "/addr", "/Address":
		if op.Kind == OpLog {
			fmt.Printf("DEEP LOG: %v (at %s, field value: %v)\n", op.New, op.Path, t.Address)
			return true, nil
		}
		if op.Kind == OpReplace && op.Strict {
			if t.Address != op.Old.(string) {
				return true, fmt.Errorf("strict check failed at %s: expected %v, got %v", op.Path, op.Old, t.Address)
			}
		}
		if v, ok := op.New.(string); ok {
			t.Address = v
			return true, nil
		}
	default:
	}
	return false, nil
}

// Diff compares t with other and returns a Patch.
func (t *Detail) Diff(other *Detail) Patch[Detail] {
	p := NewPatch[Detail]()
	if t.Age != other.Age {
		p.Operations = append(p.Operations, Operation{
			Kind: OpReplace,
			Path: "/Age",
			Old:  t.Age,
			New:  other.Age,
		})
	}
	if t.Address != other.Address {
		p.Operations = append(p.Operations, Operation{
			Kind: OpReplace,
			Path: "/addr",
			Old:  t.Address,
			New:  other.Address,
		})
	}
	return p
}

func (t *Detail) evaluateCondition(c Condition) (bool, error) {
	switch c.Op {
	case "and":
		for _, sub := range c.Apply {
			ok, err := t.evaluateCondition(*sub)
			if err != nil || !ok {
				return false, err
			}
		}
		return true, nil
	case "or":
		for _, sub := range c.Apply {
			ok, err := t.evaluateCondition(*sub)
			if err == nil && ok {
				return true, nil
			}
		}
		return false, nil
	case "not":
		if len(c.Apply) > 0 {
			ok, err := t.evaluateCondition(*c.Apply[0])
			if err != nil {
				return false, err
			}
			return !ok, nil
		}
		return true, nil
	}

	switch c.Path {
	case "/Age":
		switch c.Op {
		case "==":
			return t.Age == c.Value.(int), nil
		case "!=":
			return t.Age != c.Value.(int), nil
		case "log":
			fmt.Printf("DEEP LOG CONDITION: %v (at %s, value: %v)\n", c.Value, c.Path, t.Age)
			return true, nil
		case "matches":
			return regexp.MatchString(c.Value.(string), fmt.Sprintf("%v", t.Age))
		case "type":
			return CheckType(t.Age, c.Value.(string)), nil
		}
	case "/addr", "/Address":
		switch c.Op {
		case "==":
			return t.Address == c.Value.(string), nil
		case "!=":
			return t.Address != c.Value.(string), nil
		case "log":
			fmt.Printf("DEEP LOG CONDITION: %v (at %s, value: %v)\n", c.Value, c.Path, t.Address)
			return true, nil
		case "matches":
			return regexp.MatchString(c.Value.(string), fmt.Sprintf("%v", t.Address))
		case "type":
			return CheckType(t.Address, c.Value.(string)), nil
		}
	}
	return false, fmt.Errorf("unsupported condition path or op: %s", c.Path)
}

// Equal returns true if t and other are deeply equal.
func (t *Detail) Equal(other *Detail) bool {
	if t.Age != other.Age {
		return false
	}
	if t.Address != other.Address {
		return false
	}
	return true
}

// Copy returns a deep copy of t.
func (t *Detail) Copy() *Detail {
	res := &Detail{
		Age:     t.Age,
		Address: t.Address,
	}
	return res
}

func contains[M ~map[K]V, K comparable, V any](m M, k K) bool {
	_, ok := m[k]
	return ok
}

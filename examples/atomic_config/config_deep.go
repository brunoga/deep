// Code generated by deep-gen. DO NOT EDIT.
package main

import (
	"fmt"
	"github.com/brunoga/deep/v5"
	"regexp"
)

// ApplyOperation applies a single operation to ProxyConfig efficiently.
func (t *ProxyConfig) ApplyOperation(op v5.Operation) (bool, error) {
	if op.If != nil {
		ok, err := t.evaluateCondition(*op.If)
		if err != nil || !ok {
			return true, err
		}
	}
	if op.Unless != nil {
		ok, err := t.evaluateCondition(*op.Unless)
		if err == nil && ok {
			return true, nil
		}
	}

	if op.Path == "" || op.Path == "/" {
		if v, ok := op.New.(ProxyConfig); ok {
			*t = v
			return true, nil
		}
		if m, ok := op.New.(map[string]any); ok {
			for k, v := range m {
				t.ApplyOperation(v5.Operation{Kind: op.Kind, Path: "/" + k, New: v})
			}
			return true, nil
		}
	}

	switch op.Path {
	case "/host", "/Host":
		if op.Kind == v5.OpLog {
			fmt.Printf("DEEP LOG: %v (at %s, field value: %v)\n", op.New, op.Path, t.Host)
			return true, nil
		}
		if op.Kind == v5.OpReplace && op.Strict {
			if t.Host != op.Old.(string) {
				return true, fmt.Errorf("strict check failed at %s: expected %v, got %v", op.Path, op.Old, t.Host)
			}
		}
		if v, ok := op.New.(string); ok {
			t.Host = v
			return true, nil
		}
	case "/port", "/Port":
		if op.Kind == v5.OpLog {
			fmt.Printf("DEEP LOG: %v (at %s, field value: %v)\n", op.New, op.Path, t.Port)
			return true, nil
		}
		if op.Kind == v5.OpReplace && op.Strict {
			if t.Port != op.Old.(int) {
				return true, fmt.Errorf("strict check failed at %s: expected %v, got %v", op.Path, op.Old, t.Port)
			}
		}
		if v, ok := op.New.(int); ok {
			t.Port = v
			return true, nil
		}
		if f, ok := op.New.(float64); ok {
			t.Port = int(f)
			return true, nil
		}
	default:
	}
	return false, nil
}

// Diff compares t with other and returns a Patch.
func (t *ProxyConfig) Diff(other *ProxyConfig) v5.Patch[ProxyConfig] {
	p := v5.NewPatch[ProxyConfig]()
	if t.Host != other.Host {
		p.Operations = append(p.Operations, v5.Operation{
			Kind: v5.OpReplace,
			Path: "/host",
			Old:  t.Host,
			New:  other.Host,
		})
	}
	if t.Port != other.Port {
		p.Operations = append(p.Operations, v5.Operation{
			Kind: v5.OpReplace,
			Path: "/port",
			Old:  t.Port,
			New:  other.Port,
		})
	}
	return p
}

func (t *ProxyConfig) evaluateCondition(c v5.Condition) (bool, error) {
	switch c.Op {
	case "and":
		for _, sub := range c.Apply {
			ok, err := t.evaluateCondition(*sub)
			if err != nil || !ok {
				return false, err
			}
		}
		return true, nil
	case "or":
		for _, sub := range c.Apply {
			ok, err := t.evaluateCondition(*sub)
			if err == nil && ok {
				return true, nil
			}
		}
		return false, nil
	case "not":
		if len(c.Apply) > 0 {
			ok, err := t.evaluateCondition(*c.Apply[0])
			if err != nil {
				return false, err
			}
			return !ok, nil
		}
		return true, nil
	}

	switch c.Path {
	case "/host", "/Host":
		switch c.Op {
		case "==":
			return t.Host == c.Value.(string), nil
		case "!=":
			return t.Host != c.Value.(string), nil
		case "log":
			fmt.Printf("DEEP LOG CONDITION: %v (at %s, value: %v)\n", c.Value, c.Path, t.Host)
			return true, nil
		case "matches":
			return regexp.MatchString(c.Value.(string), fmt.Sprintf("%v", t.Host))
		case "type":
			return v5.CheckType(t.Host, c.Value.(string)), nil
		}
	case "/port", "/Port":
		switch c.Op {
		case "==":
			return t.Port == c.Value.(int), nil
		case "!=":
			return t.Port != c.Value.(int), nil
		case "log":
			fmt.Printf("DEEP LOG CONDITION: %v (at %s, value: %v)\n", c.Value, c.Path, t.Port)
			return true, nil
		case "matches":
			return regexp.MatchString(c.Value.(string), fmt.Sprintf("%v", t.Port))
		case "type":
			return v5.CheckType(t.Port, c.Value.(string)), nil
		}
	}
	return false, fmt.Errorf("unsupported condition path or op: %s", c.Path)
}

// Equal returns true if t and other are deeply equal.
func (t *ProxyConfig) Equal(other *ProxyConfig) bool {
	if t.Host != other.Host {
		return false
	}
	if t.Port != other.Port {
		return false
	}
	return true
}

// Copy returns a deep copy of t.
func (t *ProxyConfig) Copy() *ProxyConfig {
	res := &ProxyConfig{
		Host: t.Host,
		Port: t.Port,
	}
	return res
}

// ApplyOperation applies a single operation to SystemMeta efficiently.
func (t *SystemMeta) ApplyOperation(op v5.Operation) (bool, error) {
	if op.If != nil {
		ok, err := t.evaluateCondition(*op.If)
		if err != nil || !ok {
			return true, err
		}
	}
	if op.Unless != nil {
		ok, err := t.evaluateCondition(*op.Unless)
		if err == nil && ok {
			return true, nil
		}
	}

	if op.Path == "" || op.Path == "/" {
		if v, ok := op.New.(SystemMeta); ok {
			*t = v
			return true, nil
		}
		if m, ok := op.New.(map[string]any); ok {
			for k, v := range m {
				t.ApplyOperation(v5.Operation{Kind: op.Kind, Path: "/" + k, New: v})
			}
			return true, nil
		}
	}

	switch op.Path {
	case "/cid", "/ClusterID":
		return true, fmt.Errorf("field %s is read-only", op.Path)
	case "/proxy", "/Settings":
		if op.Kind == v5.OpLog {
			fmt.Printf("DEEP LOG: %v (at %s, field value: %v)\n", op.New, op.Path, t.Settings)
			return true, nil
		}
		if op.Kind == v5.OpReplace && op.Strict {
			// Complex strict check skipped in prototype
		}
		if v, ok := op.New.(ProxyConfig); ok {
			t.Settings = v
			return true, nil
		}
	default:
	}
	return false, nil
}

// Diff compares t with other and returns a Patch.
func (t *SystemMeta) Diff(other *SystemMeta) v5.Patch[SystemMeta] {
	p := v5.NewPatch[SystemMeta]()
	if t.ClusterID != other.ClusterID {
		p.Operations = append(p.Operations, v5.Operation{
			Kind: v5.OpReplace,
			Path: "/cid",
			Old:  t.ClusterID,
			New:  other.ClusterID,
		})
	}
	if t.Settings != other.Settings {
		p.Operations = append(p.Operations, v5.Operation{
			Kind: v5.OpReplace,
			Path: "/proxy",
			Old:  t.Settings,
			New:  other.Settings,
		})
	}
	return p
}

func (t *SystemMeta) evaluateCondition(c v5.Condition) (bool, error) {
	switch c.Op {
	case "and":
		for _, sub := range c.Apply {
			ok, err := t.evaluateCondition(*sub)
			if err != nil || !ok {
				return false, err
			}
		}
		return true, nil
	case "or":
		for _, sub := range c.Apply {
			ok, err := t.evaluateCondition(*sub)
			if err == nil && ok {
				return true, nil
			}
		}
		return false, nil
	case "not":
		if len(c.Apply) > 0 {
			ok, err := t.evaluateCondition(*c.Apply[0])
			if err != nil {
				return false, err
			}
			return !ok, nil
		}
		return true, nil
	}

	switch c.Path {
	case "/cid", "/ClusterID":
		switch c.Op {
		case "==":
			return t.ClusterID == c.Value.(string), nil
		case "!=":
			return t.ClusterID != c.Value.(string), nil
		case "log":
			fmt.Printf("DEEP LOG CONDITION: %v (at %s, value: %v)\n", c.Value, c.Path, t.ClusterID)
			return true, nil
		case "matches":
			return regexp.MatchString(c.Value.(string), fmt.Sprintf("%v", t.ClusterID))
		case "type":
			return v5.CheckType(t.ClusterID, c.Value.(string)), nil
		}
	}
	return false, fmt.Errorf("unsupported condition path or op: %s", c.Path)
}

// Equal returns true if t and other are deeply equal.
func (t *SystemMeta) Equal(other *SystemMeta) bool {
	if t.ClusterID != other.ClusterID {
		return false
	}
	if ((&t.Settings) == nil) != ((&other.Settings) == nil) {
		return false
	}
	if (&t.Settings) != nil && !(&t.Settings).Equal((&other.Settings)) {
		return false
	}
	return true
}

// Copy returns a deep copy of t.
func (t *SystemMeta) Copy() *SystemMeta {
	res := &SystemMeta{
		ClusterID: t.ClusterID,
	}
	if (&t.Settings) != nil {
		res.Settings = *(&t.Settings).Copy()
	}
	return res
}

func contains[M ~map[K]V, K comparable, V any](m M, k K) bool {
	_, ok := m[k]
	return ok
}

func CheckType(v any, typeName string) bool {
	switch typeName {
	case "string":
		_, ok := v.(string)
		return ok
	case "number":
		switch v.(type) {
		case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64:
			return true
		}
	case "boolean":
		_, ok := v.(bool)
		return ok
	}
	return false
}

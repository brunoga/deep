// Code generated by deep-gen. DO NOT EDIT.
package main

import (
	"fmt"
	"reflect"
	"strings"

	v5 "github.com/brunoga/deep/v5"
)

// ApplyOperation applies a single operation to Workspace efficiently.
func (t *Workspace) ApplyOperation(op v5.Operation) (bool, error) {
	if op.If != nil {
		ok, err := t.evaluateCondition(*op.If)
		if err != nil || !ok {
			return true, err
		}
	}
	if op.Unless != nil {
		ok, err := t.evaluateCondition(*op.Unless)
		if err == nil && ok {
			return true, nil
		}
	}

	if op.Path == "" || op.Path == "/" {
		if v, ok := op.New.(Workspace); ok {
			*t = v
			return true, nil
		}
		if m, ok := op.New.(map[string]any); ok {
			for k, v := range m {
				t.ApplyOperation(v5.Operation{Kind: op.Kind, Path: "/" + k, New: v})
			}
			return true, nil
		}
	}

	switch op.Path {
	case "/drafts", "/Drafts":
		if op.Kind == v5.OpLog {
			fmt.Printf("DEEP LOG: %v (at %s, field value: %v)\n", op.New, op.Path, t.Drafts)
			return true, nil
		}
		if op.Kind == v5.OpReplace && op.Strict {
			// Complex strict check skipped in prototype
		}
		if v, ok := op.New.([]string); ok {
			t.Drafts = v
			return true, nil
		}
	case "/archive", "/Archive":
		if op.Kind == v5.OpLog {
			fmt.Printf("DEEP LOG: %v (at %s, field value: %v)\n", op.New, op.Path, t.Archive)
			return true, nil
		}
		if op.Kind == v5.OpReplace && op.Strict {
			// Complex strict check skipped in prototype
		}
		if v, ok := op.New.(map[string]string); ok {
			t.Archive = v
			return true, nil
		}
	default:
		if strings.HasPrefix(op.Path, "/archive/") {
			parts := strings.Split(op.Path[len("/archive/"):], "/")
			key := parts[0]
			if op.Kind == v5.OpRemove {
				delete(t.Archive, key)
				return true, nil
			} else {
				if t.Archive == nil {
					t.Archive = make(map[string]string)
				}
				if v, ok := op.New.(string); ok {
					t.Archive[key] = v
					return true, nil
				}
			}
		}
	}
	return false, nil
}

// Diff compares t with other and returns a Patch.
func (t *Workspace) Diff(other *Workspace) v5.Patch[Workspace] {
	p := v5.NewPatch[Workspace]()
	if len(t.Drafts) != len(other.Drafts) {
		p.Operations = append(p.Operations, v5.Operation{
			Kind: v5.OpReplace,
			Path: "/drafts",
			Old:  t.Drafts,
			New:  other.Drafts,
		})
	} else {
		for i := range t.Drafts {
			if t.Drafts[i] != other.Drafts[i] {
				p.Operations = append(p.Operations, v5.Operation{
					Kind: v5.OpReplace,
					Path: fmt.Sprintf("/drafts/%d", i),
					Old:  t.Drafts[i],
					New:  other.Drafts[i],
				})
			}
		}
	}
	if other.Archive != nil {
		for k, v := range other.Archive {
			if t.Archive == nil {
				p.Operations = append(p.Operations, v5.Operation{
					Kind: v5.OpReplace,
					Path: fmt.Sprintf("/archive/%v", k),
					New:  v,
				})
				continue
			}
			if oldV, ok := t.Archive[k]; !ok || v != oldV {
				kind := v5.OpReplace
				if !ok {
					kind = v5.OpAdd
				}
				p.Operations = append(p.Operations, v5.Operation{
					Kind: kind,
					Path: fmt.Sprintf("/archive/%v", k),
					Old:  oldV,
					New:  v,
				})
			}
		}
	}
	if t.Archive != nil {
		for k, v := range t.Archive {
			if other.Archive == nil || !contains(other.Archive, k) {
				p.Operations = append(p.Operations, v5.Operation{
					Kind: v5.OpRemove,
					Path: fmt.Sprintf("/archive/%v", k),
					Old:  v,
				})
			}
		}
	}
	return p
}

func (t *Workspace) evaluateCondition(c v5.Condition) (bool, error) {
	switch c.Op {
	case "and":
		for _, sub := range c.Apply {
			ok, err := t.evaluateCondition(*sub)
			if err != nil || !ok {
				return false, err
			}
		}
		return true, nil
	case "or":
		for _, sub := range c.Apply {
			ok, err := t.evaluateCondition(*sub)
			if err == nil && ok {
				return true, nil
			}
		}
		return false, nil
	case "not":
		if len(c.Apply) > 0 {
			ok, err := t.evaluateCondition(*c.Apply[0])
			if err != nil {
				return false, err
			}
			return !ok, nil
		}
		return true, nil
	}

	switch c.Path {
	}
	return false, fmt.Errorf("unsupported condition path or op: %s", c.Path)
}

// Equal returns true if t and other are deeply equal.
func (t *Workspace) Equal(other *Workspace) bool {
	if len(t.Drafts) != len(other.Drafts) {
		return false
	}
	if len(t.Archive) != len(other.Archive) {
		return false
	}
	return true
}

// Copy returns a deep copy of t.
func (t *Workspace) Copy() *Workspace {
	res := &Workspace{
		Drafts: append([]string(nil), t.Drafts...),
	}
	if t.Archive != nil {
		res.Archive = make(map[string]string)
		for k, v := range t.Archive {
			res.Archive[k] = v
		}
	}
	return res
}

func contains[M ~map[K]V, K comparable, V any](m M, k K) bool {
	_, ok := m[k]
	return ok
}

func checkType(v any, typeName string) bool {
	switch typeName {
	case "string":
		_, ok := v.(string)
		return ok
	case "number":
		switch v.(type) {
		case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64:
			return true
		}
	case "boolean":
		_, ok := v.(bool)
		return ok
	case "object":
		rv := reflect.ValueOf(v)
		return rv.Kind() == reflect.Struct || rv.Kind() == reflect.Map
	case "array":
		rv := reflect.ValueOf(v)
		return rv.Kind() == reflect.Slice || rv.Kind() == reflect.Array
	case "null":
		if v == nil {
			return true
		}
		rv := reflect.ValueOf(v)
		return (rv.Kind() == reflect.Pointer || rv.Kind() == reflect.Interface || rv.Kind() == reflect.Slice || rv.Kind() == reflect.Map) && rv.IsNil()
	}
	return false
}

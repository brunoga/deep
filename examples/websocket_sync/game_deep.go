// Code generated by deep-gen. DO NOT EDIT.
package main

import (
	"fmt"
	"github.com/brunoga/deep/v5"
	"strings"
)

// ApplyOperation applies a single operation to GameWorld efficiently.
func (t *GameWorld) ApplyOperation(op v5.Operation) (bool, error) {
	if op.If != nil {
		ok, err := t.evaluateCondition(*op.If)
		if err != nil || !ok {
			return true, err
		}
	}
	if op.Unless != nil {
		ok, err := t.evaluateCondition(*op.Unless)
		if err == nil && ok {
			return true, nil
		}
	}

	if op.Path == "" || op.Path == "/" {
		if v, ok := op.New.(GameWorld); ok {
			*t = v
			return true, nil
		}
		if m, ok := op.New.(map[string]any); ok {
			for k, v := range m {
				t.ApplyOperation(v5.Operation{Kind: op.Kind, Path: "/" + k, New: v})
			}
			return true, nil
		}
	}

	switch op.Path {
	case "/players", "/Players":
		if v, ok := op.New.(map[string]*Player); ok {
			t.Players = v
			return true, nil
		}
	case "/time", "/Time":
		if v, ok := op.New.(int); ok {
			t.Time = v
			return true, nil
		}
		if f, ok := op.New.(float64); ok {
			t.Time = int(f)
			return true, nil
		}
	default:
		if strings.HasPrefix(op.Path, "/players/") {
			parts := strings.Split(op.Path[len("/players/"):], "/")
			key := parts[0]
			if val, ok := t.Players[key]; ok && val != nil {
				op.Path = "/"
				if len(parts) > 1 {
					op.Path = "/" + strings.Join(parts[1:], "/")
				}
				return val.ApplyOperation(op)
			}
		}
	}
	return false, nil
}

// Diff compares t with other and returns a Patch.
func (t *GameWorld) Diff(other *GameWorld) v5.Patch[GameWorld] {
	p := v5.NewPatch[GameWorld]()
	if other.Players != nil {
		for k, v := range other.Players {
			if t.Players == nil {
				p.Operations = append(p.Operations, v5.Operation{
					Kind: v5.OpReplace,
					Path: fmt.Sprintf("/players/%v", k),
					New:  v,
				})
				continue
			}
			if oldV, ok := t.Players[k]; !ok || !oldV.Equal(v) {
				p.Operations = append(p.Operations, v5.Operation{
					Kind: v5.OpReplace,
					Path: fmt.Sprintf("/players/%v", k),
					Old:  oldV,
					New:  v,
				})
			}
		}
	}
	if t.Players != nil {
		for k, v := range t.Players {
			if other.Players == nil || !contains(other.Players, k) {
				p.Operations = append(p.Operations, v5.Operation{
					Kind: v5.OpRemove,
					Path: fmt.Sprintf("/players/%v", k),
					Old:  v,
				})
			}
		}
	}
	if t.Time != other.Time {
		p.Operations = append(p.Operations, v5.Operation{
			Kind: v5.OpReplace,
			Path: "/time",
			Old:  t.Time,
			New:  other.Time,
		})
	}
	return p
}

func (t *GameWorld) evaluateCondition(c v5.Condition) (bool, error) {
	switch c.Path {
	case "/time", "/Time":
		switch c.Op {
		case "==":
			return t.Time == c.Value.(int), nil
		case "!=":
			return t.Time != c.Value.(int), nil
		}
	}
	return false, fmt.Errorf("unsupported condition path or op: %s", c.Path)
}

// Equal returns true if t and other are deeply equal.
func (t *GameWorld) Equal(other *GameWorld) bool {
	if len(t.Players) != len(other.Players) {
		return false
	}
	if t.Time != other.Time {
		return false
	}
	return true
}

// Copy returns a deep copy of t.
func (t *GameWorld) Copy() *GameWorld {
	res := &GameWorld{
		Time: t.Time,
	}
	if t.Players != nil {
		res.Players = make(map[string]*Player)
		for k, v := range t.Players {
			if v != nil {
				res.Players[k] = v.Copy()
			}
		}
	}
	return res
}

// ApplyOperation applies a single operation to Player efficiently.
func (t *Player) ApplyOperation(op v5.Operation) (bool, error) {
	if op.If != nil {
		ok, err := t.evaluateCondition(*op.If)
		if err != nil || !ok {
			return true, err
		}
	}
	if op.Unless != nil {
		ok, err := t.evaluateCondition(*op.Unless)
		if err == nil && ok {
			return true, nil
		}
	}

	if op.Path == "" || op.Path == "/" {
		if v, ok := op.New.(Player); ok {
			*t = v
			return true, nil
		}
		if m, ok := op.New.(map[string]any); ok {
			for k, v := range m {
				t.ApplyOperation(v5.Operation{Kind: op.Kind, Path: "/" + k, New: v})
			}
			return true, nil
		}
	}

	switch op.Path {
	case "/x", "/X":
		if v, ok := op.New.(int); ok {
			t.X = v
			return true, nil
		}
		if f, ok := op.New.(float64); ok {
			t.X = int(f)
			return true, nil
		}
	case "/y", "/Y":
		if v, ok := op.New.(int); ok {
			t.Y = v
			return true, nil
		}
		if f, ok := op.New.(float64); ok {
			t.Y = int(f)
			return true, nil
		}
	case "/name", "/Name":
		if v, ok := op.New.(string); ok {
			t.Name = v
			return true, nil
		}
	default:
	}
	return false, nil
}

// Diff compares t with other and returns a Patch.
func (t *Player) Diff(other *Player) v5.Patch[Player] {
	p := v5.NewPatch[Player]()
	if t.X != other.X {
		p.Operations = append(p.Operations, v5.Operation{
			Kind: v5.OpReplace,
			Path: "/x",
			Old:  t.X,
			New:  other.X,
		})
	}
	if t.Y != other.Y {
		p.Operations = append(p.Operations, v5.Operation{
			Kind: v5.OpReplace,
			Path: "/y",
			Old:  t.Y,
			New:  other.Y,
		})
	}
	if t.Name != other.Name {
		p.Operations = append(p.Operations, v5.Operation{
			Kind: v5.OpReplace,
			Path: "/name",
			Old:  t.Name,
			New:  other.Name,
		})
	}
	return p
}

func (t *Player) evaluateCondition(c v5.Condition) (bool, error) {
	switch c.Path {
	case "/x", "/X":
		switch c.Op {
		case "==":
			return t.X == c.Value.(int), nil
		case "!=":
			return t.X != c.Value.(int), nil
		}
	case "/y", "/Y":
		switch c.Op {
		case "==":
			return t.Y == c.Value.(int), nil
		case "!=":
			return t.Y != c.Value.(int), nil
		}
	case "/name", "/Name":
		switch c.Op {
		case "==":
			return t.Name == c.Value.(string), nil
		case "!=":
			return t.Name != c.Value.(string), nil
		}
	}
	return false, fmt.Errorf("unsupported condition path or op: %s", c.Path)
}

// Equal returns true if t and other are deeply equal.
func (t *Player) Equal(other *Player) bool {
	if t.X != other.X {
		return false
	}
	if t.Y != other.Y {
		return false
	}
	if t.Name != other.Name {
		return false
	}
	return true
}

// Copy returns a deep copy of t.
func (t *Player) Copy() *Player {
	res := &Player{
		X:    t.X,
		Y:    t.Y,
		Name: t.Name,
	}
	return res
}

func contains[M ~map[K]V, K comparable, V any](m M, k K) bool {
	_, ok := m[k]
	return ok
}

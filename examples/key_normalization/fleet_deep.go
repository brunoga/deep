// Code generated by deep-gen. DO NOT EDIT.
package main

import (
	"fmt"
	"github.com/brunoga/deep/v5"
)

// ApplyOperation applies a single operation to Fleet efficiently.
func (t *Fleet) ApplyOperation(op v5.Operation) (bool, error) {
	if op.If != nil {
		ok, err := t.evaluateCondition(*op.If)
		if err != nil || !ok {
			return true, err
		}
	}
	if op.Unless != nil {
		ok, err := t.evaluateCondition(*op.Unless)
		if err == nil && ok {
			return true, nil
		}
	}

	if op.Path == "" || op.Path == "/" {
		if v, ok := op.New.(Fleet); ok {
			*t = v
			return true, nil
		}
		if m, ok := op.New.(map[string]any); ok {
			for k, v := range m {
				t.ApplyOperation(v5.Operation{Kind: op.Kind, Path: "/" + k, New: v})
			}
			return true, nil
		}
	}

	switch op.Path {
	case "/devices", "/Devices":
		if v, ok := op.New.(map[DeviceID]string); ok {
			t.Devices = v
			return true, nil
		}
	default:
	}
	return false, nil
}

// Diff compares t with other and returns a Patch.
func (t *Fleet) Diff(other *Fleet) v5.Patch[Fleet] {
	p := v5.NewPatch[Fleet]()
	if other.Devices != nil {
		for k, v := range other.Devices {
			if t.Devices == nil {
				p.Operations = append(p.Operations, v5.Operation{
					Kind: v5.OpReplace,
					Path: fmt.Sprintf("/devices/%v", k),
					New:  v,
				})
				continue
			}
			if oldV, ok := t.Devices[k]; !ok || v != oldV {
				p.Operations = append(p.Operations, v5.Operation{
					Kind: v5.OpReplace,
					Path: fmt.Sprintf("/devices/%v", k),
					Old:  oldV,
					New:  v,
				})
			}
		}
	}
	if t.Devices != nil {
		for k, v := range t.Devices {
			if other.Devices == nil || !contains(other.Devices, k) {
				p.Operations = append(p.Operations, v5.Operation{
					Kind: v5.OpRemove,
					Path: fmt.Sprintf("/devices/%v", k),
					Old:  v,
				})
			}
		}
	}
	return p
}

func (t *Fleet) evaluateCondition(c v5.Condition) (bool, error) {
	switch c.Path {
	}
	return false, fmt.Errorf("unsupported condition path or op: %s", c.Path)
}

// Equal returns true if t and other are deeply equal.
func (t *Fleet) Equal(other *Fleet) bool {
	if len(t.Devices) != len(other.Devices) {
		return false
	}
	return true
}

// Copy returns a deep copy of t.
func (t *Fleet) Copy() *Fleet {
	res := &Fleet{}
	if t.Devices != nil {
		res.Devices = make(map[DeviceID]string)
		for k, v := range t.Devices {
			res.Devices[k] = v
		}
	}
	return res
}

func contains[M ~map[K]V, K comparable, V any](m M, k K) bool {
	_, ok := m[k]
	return ok
}

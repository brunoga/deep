// Code generated by deep-gen. DO NOT EDIT.
package main

import (
	"fmt"
	"github.com/brunoga/deep/v5"
)

// ApplyOperation applies a single operation to Item efficiently.
func (t *Item) ApplyOperation(op v5.Operation) (bool, error) {
	if op.If != nil {
		ok, err := t.evaluateCondition(*op.If)
		if err != nil || !ok {
			return true, err
		}
	}
	if op.Unless != nil {
		ok, err := t.evaluateCondition(*op.Unless)
		if err == nil && ok {
			return true, nil
		}
	}

	if op.Path == "" || op.Path == "/" {
		if v, ok := op.New.(Item); ok {
			*t = v
			return true, nil
		}
		if m, ok := op.New.(map[string]any); ok {
			for k, v := range m {
				t.ApplyOperation(v5.Operation{Kind: op.Kind, Path: "/" + k, New: v})
			}
			return true, nil
		}
	}

	switch op.Path {
	case "/sku", "/SKU":
		if v, ok := op.New.(string); ok {
			t.SKU = v
			return true, nil
		}
	case "/q", "/Quantity":
		if v, ok := op.New.(int); ok {
			t.Quantity = v
			return true, nil
		}
		if f, ok := op.New.(float64); ok {
			t.Quantity = int(f)
			return true, nil
		}
	default:
	}
	return false, nil
}

// Diff compares t with other and returns a Patch.
func (t *Item) Diff(other *Item) v5.Patch[Item] {
	p := v5.NewPatch[Item]()
	if t.SKU != other.SKU {
		p.Operations = append(p.Operations, v5.Operation{
			Kind: v5.OpReplace,
			Path: "/sku",
			Old:  t.SKU,
			New:  other.SKU,
		})
	}
	if t.Quantity != other.Quantity {
		p.Operations = append(p.Operations, v5.Operation{
			Kind: v5.OpReplace,
			Path: "/q",
			Old:  t.Quantity,
			New:  other.Quantity,
		})
	}
	return p
}

func (t *Item) evaluateCondition(c v5.Condition) (bool, error) {
	switch c.Path {
	case "/sku", "/SKU":
		switch c.Op {
		case "==":
			return t.SKU == c.Value.(string), nil
		case "!=":
			return t.SKU != c.Value.(string), nil
		}
	case "/q", "/Quantity":
		switch c.Op {
		case "==":
			return t.Quantity == c.Value.(int), nil
		case "!=":
			return t.Quantity != c.Value.(int), nil
		}
	}
	return false, fmt.Errorf("unsupported condition path or op: %s", c.Path)
}

// Equal returns true if t and other are deeply equal.
func (t *Item) Equal(other *Item) bool {
	if t.SKU != other.SKU {
		return false
	}
	if t.Quantity != other.Quantity {
		return false
	}
	return true
}

// Copy returns a deep copy of t.
func (t *Item) Copy() *Item {
	res := &Item{
		SKU:      t.SKU,
		Quantity: t.Quantity,
	}
	return res
}

// ApplyOperation applies a single operation to Inventory efficiently.
func (t *Inventory) ApplyOperation(op v5.Operation) (bool, error) {
	if op.If != nil {
		ok, err := t.evaluateCondition(*op.If)
		if err != nil || !ok {
			return true, err
		}
	}
	if op.Unless != nil {
		ok, err := t.evaluateCondition(*op.Unless)
		if err == nil && ok {
			return true, nil
		}
	}

	if op.Path == "" || op.Path == "/" {
		if v, ok := op.New.(Inventory); ok {
			*t = v
			return true, nil
		}
		if m, ok := op.New.(map[string]any); ok {
			for k, v := range m {
				t.ApplyOperation(v5.Operation{Kind: op.Kind, Path: "/" + k, New: v})
			}
			return true, nil
		}
	}

	switch op.Path {
	case "/items", "/Items":
		if v, ok := op.New.([]Item); ok {
			t.Items = v
			return true, nil
		}
	default:
	}
	return false, nil
}

// Diff compares t with other and returns a Patch.
func (t *Inventory) Diff(other *Inventory) v5.Patch[Inventory] {
	p := v5.NewPatch[Inventory]()
	// Keyed slice diff
	otherByKey := make(map[any]int)
	for i, v := range other.Items {
		otherByKey[v.SKU] = i
	}
	for _, v := range t.Items {
		if _, ok := otherByKey[v.SKU]; !ok {
			p.Operations = append(p.Operations, v5.Operation{
				Kind: v5.OpRemove,
				Path: fmt.Sprintf("/items/%v", v.SKU),
				Old:  v,
			})
		}
	}
	tByKey := make(map[any]int)
	for i, v := range t.Items {
		tByKey[v.SKU] = i
	}
	for _, v := range other.Items {
		if _, ok := tByKey[v.SKU]; !ok {
			p.Operations = append(p.Operations, v5.Operation{
				Kind: v5.OpAdd,
				Path: fmt.Sprintf("/items/%v", v.SKU),
				New:  v,
			})
		}
	}
	return p
}

func (t *Inventory) evaluateCondition(c v5.Condition) (bool, error) {
	switch c.Path {
	}
	return false, fmt.Errorf("unsupported condition path or op: %s", c.Path)
}

// Equal returns true if t and other are deeply equal.
func (t *Inventory) Equal(other *Inventory) bool {
	if len(t.Items) != len(other.Items) {
		return false
	}
	return true
}

// Copy returns a deep copy of t.
func (t *Inventory) Copy() *Inventory {
	res := &Inventory{
		Items: append([]Item(nil), t.Items...),
	}
	return res
}

func contains[M ~map[K]V, K comparable, V any](m M, k K) bool {
	_, ok := m[k]
	return ok
}

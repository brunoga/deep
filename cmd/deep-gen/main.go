package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"reflect"
	"strings"
)

var (
	typeNames = flag.String("type", "", "comma-separated list of type names; must be set")
)

// Generator holds the state of the analysis.
type Generator struct {
	pkgName  string
	buf      strings.Builder
	typeKeys map[string]string // typeName -> keyFieldName
}

func (g *Generator) header(fields []FieldInfo) {
	g.buf.WriteString(fmt.Sprintf("// Code generated by deep-gen. DO NOT EDIT.\n"))
	g.buf.WriteString(fmt.Sprintf("package %s\n\n", g.pkgName))
	g.buf.WriteString("import (\n")
	g.buf.WriteString("\t\"fmt\"\n")
	g.buf.WriteString("\t\"regexp\"\n")

	if g.pkgName != "deep" {
		g.buf.WriteString("\t\"reflect\"\n")
	}

	needsStrings := false
	for _, f := range fields {
		if f.Ignore {
			continue
		}
		if (f.IsStruct || f.IsCollection) && !f.Atomic {
			needsStrings = true
			break
		}
	}
	if needsStrings {
		g.buf.WriteString("\t\"strings\"\n")
	}

	if g.pkgName != "deep" {
		g.buf.WriteString("\t\"github.com/brunoga/deep/v5\"\n")
	}
	g.buf.WriteString(")\n\n")
}

func (g *Generator) generate(typeName string, fields []FieldInfo) {
	pkgPrefix := ""
	if g.pkgName != "deep" {
		pkgPrefix = "v5."
	}

	g.buf.WriteString(fmt.Sprintf("// ApplyOperation applies a single operation to %s efficiently.\n", typeName))
	g.buf.WriteString(fmt.Sprintf("func (t *%s) ApplyOperation(op %sOperation) (bool, error) {\n", typeName, pkgPrefix))

	// Conditions
	g.buf.WriteString("\tif op.If != nil {\n")
	g.buf.WriteString("\t\tok, err := t.evaluateCondition(*op.If)\n")
	g.buf.WriteString("\t\tif err != nil || !ok { return true, err }\n")
	g.buf.WriteString("\t}\n")
	g.buf.WriteString("\tif op.Unless != nil {\n")
	g.buf.WriteString("\t\tok, err := t.evaluateCondition(*op.Unless)\n")
	g.buf.WriteString("\t\tif err == nil && ok { return true, nil }\n")
	g.buf.WriteString("\t}\n\n")

	g.buf.WriteString("\tif op.Path == \"\" || op.Path == \"/\" {\n")
	g.buf.WriteString(fmt.Sprintf("\t\tif v, ok := op.New.(%s); ok {\n", typeName))
	g.buf.WriteString("\t\t\t*t = v\n")
	g.buf.WriteString("\t\t\treturn true, nil\n")
	g.buf.WriteString("\t\t}\n")
	g.buf.WriteString("\t\tif m, ok := op.New.(map[string]any); ok {\n")
	g.buf.WriteString("\t\t\tfor k, v := range m {\n")
	g.buf.WriteString(fmt.Sprintf("\t\t\t\tt.ApplyOperation(%sOperation{Kind: op.Kind, Path: \"/\" + k, New: v})\n", pkgPrefix))
	g.buf.WriteString("\t\t\t}\n")
	g.buf.WriteString("\t\t\treturn true, nil\n")
	g.buf.WriteString("\t\t}\n")
	g.buf.WriteString("\t}\n\n")

	g.buf.WriteString("\tswitch op.Path {\n")

	for _, f := range fields {
		if f.Ignore {
			continue
		}

		if f.JSONName != f.Name {
			g.buf.WriteString(fmt.Sprintf("\tcase \"/%s\", \"/%s\":\n", f.JSONName, f.Name))
		} else {
			g.buf.WriteString(fmt.Sprintf("\tcase \"/%s\":\n", f.Name))
		}

		if f.ReadOnly {
			g.buf.WriteString(fmt.Sprintf("\t\treturn true, fmt.Errorf(\"field %%s is read-only\", op.Path)\n"))
			continue
		}

		g.buf.WriteString("\t\tif op.Kind == " + pkgPrefix + "OpLog {\n")
		g.buf.WriteString(fmt.Sprintf("\t\t\tfmt.Printf(\"DEEP LOG: %%v (at %%s, field value: %%v)\\n\", op.New, op.Path, t.%s)\n", f.Name))
		g.buf.WriteString("\t\t\treturn true, nil\n")
		g.buf.WriteString("\t\t}\n")

		// Strict check for Replace ops
		g.buf.WriteString(fmt.Sprintf("\t\tif op.Kind == %sOpReplace && op.Strict {\n", pkgPrefix))
		if f.IsStruct || f.IsText || f.IsCollection {
			g.buf.WriteString("\t\t\t// Complex strict check skipped in prototype\n")
		} else {
			g.buf.WriteString(fmt.Sprintf("\t\t\tif t.%s != op.Old.(%s) {\n", f.Name, f.Type))
			g.buf.WriteString(fmt.Sprintf("\t\t\t\treturn true, fmt.Errorf(\"strict check failed at %%s: expected %%v, got %%v\", op.Path, op.Old, t.%s)\n", f.Name))
			g.buf.WriteString("\t\t\t}\n")
		}
		g.buf.WriteString("\t\t}\n")

		if (f.IsStruct || f.IsText) && !f.Atomic {
			g.buf.WriteString(fmt.Sprintf("\t\tif v, ok := op.New.(%s); ok {\n", f.Type))
			g.buf.WriteString(fmt.Sprintf("\t\t\tt.%s = v\n", f.Name))
			g.buf.WriteString("\t\t\treturn true, nil\n")
			g.buf.WriteString("\t\t}\n")
		} else if f.IsCollection && !f.Atomic {
			g.buf.WriteString(fmt.Sprintf("\t\tif v, ok := op.New.(%s); ok {\n", f.Type))
			g.buf.WriteString(fmt.Sprintf("\t\t\tt.%s = v\n", f.Name))
			g.buf.WriteString("\t\t\treturn true, nil\n")
			g.buf.WriteString("\t\t}\n")
		} else {
			g.buf.WriteString(fmt.Sprintf("\t\tif v, ok := op.New.(%s); ok {\n", f.Type))
			g.buf.WriteString(fmt.Sprintf("\t\t\tt.%s = v\n", f.Name))
			g.buf.WriteString("\t\t\treturn true, nil\n")
			g.buf.WriteString("\t\t}\n")
			// Numeric conversion fallback
			if f.Type == "int" || f.Type == "int64" || f.Type == "float64" {
				g.buf.WriteString("\t\tif f, ok := op.New.(float64); ok {\n")
				g.buf.WriteString(fmt.Sprintf("\t\t\tt.%s = %s(f)\n", f.Name, f.Type))
				g.buf.WriteString("\t\t\treturn true, nil\n")
				g.buf.WriteString("\t\t}\n")
			}
		}
	}

	g.buf.WriteString("\tdefault:\n")
	// Try nested delegation
	for _, f := range fields {
		if f.Ignore || f.Atomic {
			continue
		}

		if f.IsStruct {
			g.buf.WriteString(fmt.Sprintf("\t\tif strings.HasPrefix(op.Path, \"/%s/\") {\n", f.JSONName))
			if f.ReadOnly {
				g.buf.WriteString(fmt.Sprintf("\t\t\treturn true, fmt.Errorf(\"field %%s is read-only\", op.Path)\n"))
			} else {
				isPtr := strings.HasPrefix(f.Type, "*")
				selfArg := "(&t." + f.Name + ")"
				if isPtr {
					selfArg = "t." + f.Name
				}
				if isPtr {
					g.buf.WriteString(fmt.Sprintf("\t\t\tif %s != nil {\n", selfArg))
					g.buf.WriteString(fmt.Sprintf("\t\t\t\top.Path = op.Path[len(\"/%s/\")-1:]\n", f.JSONName))
					g.buf.WriteString(fmt.Sprintf("\t\t\t\treturn %s.ApplyOperation(op)\n", selfArg))
					g.buf.WriteString("\t\t\t}\n")
				} else {
					g.buf.WriteString(fmt.Sprintf("\t\t\top.Path = op.Path[len(\"/%s/\")-1:]\n", f.JSONName))
					g.buf.WriteString(fmt.Sprintf("\t\t\treturn %s.ApplyOperation(op)\n", selfArg))
				}
			}
			g.buf.WriteString("\t\t}\n")
		}
		if f.IsCollection && strings.HasPrefix(f.Type, "map[string]") {
			g.buf.WriteString(fmt.Sprintf("\t\tif strings.HasPrefix(op.Path, \"/%s/\") {\n", f.JSONName))
			if f.ReadOnly {
				g.buf.WriteString(fmt.Sprintf("\t\t\treturn true, fmt.Errorf(\"field %%s is read-only\", op.Path)\n"))
			} else {
				valType := f.Type[strings.Index(f.Type, "]")+1:]
				if strings.HasPrefix(valType, "*") {
					g.buf.WriteString(fmt.Sprintf("\t\t\tparts := strings.Split(op.Path[len(\"/%s/\"):], \"/\")\n", f.JSONName))
					g.buf.WriteString(fmt.Sprintf("\t\t\tkey := parts[0]\n"))
					g.buf.WriteString(fmt.Sprintf("\t\t\tif val, ok := t.%s[key]; ok && val != nil {\n", f.Name))
					g.buf.WriteString(fmt.Sprintf("\t\t\t\top.Path = \"/\"\n"))
					g.buf.WriteString(fmt.Sprintf("\t\t\t\tif len(parts) > 1 { op.Path = \"/\" + strings.Join(parts[1:], \"/\") }\n"))
					g.buf.WriteString("\t\t\t\treturn val.ApplyOperation(op)\n")
					g.buf.WriteString("\t\t\t}\n")
				} else {
					g.buf.WriteString(fmt.Sprintf("\t\t\tparts := strings.Split(op.Path[len(\"/%s/\"):], \"/\")\n", f.JSONName))
					g.buf.WriteString(fmt.Sprintf("\t\t\tkey := parts[0]\n"))
					g.buf.WriteString("\t\t\tif op.Kind == " + pkgPrefix + "OpRemove {\n")
					g.buf.WriteString("\t\t\t\tdelete(t." + f.Name + ", key)\n")
					g.buf.WriteString("\t\t\t\treturn true, nil\n")
					g.buf.WriteString("\t\t\t} else {\n")
					g.buf.WriteString("\t\t\t\tif t." + f.Name + " == nil { t." + f.Name + " = make(" + f.Type + ") }\n")
					g.buf.WriteString("\t\t\t\tif v, ok := op.New.(" + valType + "); ok {\n")
					g.buf.WriteString("\t\t\t\t\tt." + f.Name + "[key] = v\n")
					g.buf.WriteString("\t\t\t\t\treturn true, nil\n")
					g.buf.WriteString("\t\t\t\t}\n")
					g.buf.WriteString("\t\t\t}\n")
				}
			}
			g.buf.WriteString("\t\t}\n")
		}
	}
	g.buf.WriteString("\t}\n")
	g.buf.WriteString("\treturn false, nil\n")
	g.buf.WriteString("}\n\n")

	// Diff implementation
	g.buf.WriteString(fmt.Sprintf("// Diff compares t with other and returns a Patch.\n"))
	g.buf.WriteString(fmt.Sprintf("func (t *%s) Diff(other *%s) %sPatch[%s] {\n", typeName, typeName, pkgPrefix, typeName))
	g.buf.WriteString(fmt.Sprintf("\tp := %sNewPatch[%s]()\n", pkgPrefix, typeName))

	for _, f := range fields {
		if f.Ignore {
			continue
		}

		if (f.IsStruct || f.IsText) && !f.Atomic {
			isPtr := strings.HasPrefix(f.Type, "*")
			otherArg := "&other." + f.Name
			selfArg := "(&t." + f.Name + ")"
			if isPtr {
				otherArg = "other." + f.Name
				selfArg = "t." + f.Name
			}
			if f.IsText {
				otherArg = "other." + f.Name
			}

			if isPtr {
				g.buf.WriteString(fmt.Sprintf("\tif %s != nil && %s != nil {\n", selfArg, otherArg))
			} else if f.IsText {
				g.buf.WriteString(fmt.Sprintf("\tif t.%s != nil && %s != nil {\n", f.Name, otherArg))
			}

			g.buf.WriteString(fmt.Sprintf("\t\tsub%s := %s.Diff(%s)\n", f.Name, selfArg, otherArg))
			g.buf.WriteString(fmt.Sprintf("\t\tfor _, op := range sub%s.Operations {\n", f.Name))
			g.buf.WriteString(fmt.Sprintf("\t\t\tif op.Path == \"\" || op.Path == \"/\" {\n"))
			g.buf.WriteString(fmt.Sprintf("\t\t\t\top.Path = \"/%s\"\n", f.JSONName))
			g.buf.WriteString(fmt.Sprintf("\t\t\t} else {\n"))
			g.buf.WriteString(fmt.Sprintf("\t\t\t\top.Path = \"/%s\" + op.Path\n", f.JSONName))
			g.buf.WriteString(fmt.Sprintf("\t\t\t}\n"))
			g.buf.WriteString("\t\t\tp.Operations = append(p.Operations, op)\n")
			g.buf.WriteString("\t\t}\n")

			if isPtr || f.IsText {
				g.buf.WriteString("\t}\n")
			}
		} else if f.IsCollection && !f.Atomic {
			if strings.HasPrefix(f.Type, "map[") {
				g.buf.WriteString(fmt.Sprintf("\tif other.%s != nil {\n", f.Name))
				g.buf.WriteString(fmt.Sprintf("\tfor k, v := range other.%s {\n", f.Name))
				g.buf.WriteString(fmt.Sprintf("\t\tif t.%s == nil { \n", f.Name))
				g.buf.WriteString("\t\t\tp.Operations = append(p.Operations, " + pkgPrefix + "Operation{\n")
				g.buf.WriteString("\t\t\t\tKind: " + pkgPrefix + "OpReplace,\n")
				g.buf.WriteString(fmt.Sprintf("\t\t\t\tPath: fmt.Sprintf(\"/%s/%%v\", k),\n", f.JSONName))
				g.buf.WriteString("\t\t\t\tNew:  v,\n")
				g.buf.WriteString("\t\t\t})\n")
				g.buf.WriteString("\t\t\tcontinue\n")
				g.buf.WriteString("\t\t}\n")
				g.buf.WriteString(fmt.Sprintf("\t\tif oldV, ok := t.%s[k]; !ok || ", f.Name))
				valType := f.Type[strings.Index(f.Type, "]")+1:]
				if strings.HasPrefix(valType, "*") {
					g.buf.WriteString("!oldV.Equal(v) {\n")
				} else {
					g.buf.WriteString("v != oldV {\n")
				}
				g.buf.WriteString("\t\t\tkind := " + pkgPrefix + "OpReplace\n")
				g.buf.WriteString("\t\t\tif !ok { kind = " + pkgPrefix + "OpAdd }\n")
				g.buf.WriteString("\t\t\tp.Operations = append(p.Operations, " + pkgPrefix + "Operation{\n")
				g.buf.WriteString("\t\t\t\tKind: kind,\n")
				g.buf.WriteString(fmt.Sprintf("\t\t\t\tPath: fmt.Sprintf(\"/%s/%%v\", k),\n", f.JSONName))
				g.buf.WriteString("\t\t\t\tOld:  oldV,\n")
				g.buf.WriteString("\t\t\t\tNew:  v,\n")
				g.buf.WriteString("\t\t\t})\n")
				g.buf.WriteString("\t\t}\n")
				g.buf.WriteString("\t}\n")
				g.buf.WriteString("\t}\n")
				g.buf.WriteString(fmt.Sprintf("\tif t.%s != nil {\n", f.Name))
				g.buf.WriteString(fmt.Sprintf("\tfor k, v := range t.%s {\n", f.Name))
				g.buf.WriteString(fmt.Sprintf("\t\tif other.%s == nil || !contains(other.%s, k) {\n", f.Name, f.Name))
				g.buf.WriteString("\t\t\tp.Operations = append(p.Operations, " + pkgPrefix + "Operation{\n")
				g.buf.WriteString("\t\t\t\tKind: " + pkgPrefix + "OpRemove,\n")
				g.buf.WriteString(fmt.Sprintf("\t\t\t\tPath: fmt.Sprintf(\"/%s/%%v\", k),\n", f.JSONName))
				g.buf.WriteString("\t\t\t\tOld:  v,\n")
				g.buf.WriteString("\t\t\t})\n")
				g.buf.WriteString("\t\t}\n")
				g.buf.WriteString("\t}\n")
				g.buf.WriteString("\t}\n")
			} else {
				elementTypeName := f.Type[2:]
				keyField := g.typeKeys[elementTypeName]
				if keyField != "" {
					g.buf.WriteString(fmt.Sprintf("\t// Keyed slice diff\n"))
					g.buf.WriteString(fmt.Sprintf("\totherByKey := make(map[any]int)\n"))
					g.buf.WriteString(fmt.Sprintf("\tfor i, v := range other.%s {\n", f.Name))
					g.buf.WriteString(fmt.Sprintf("\t\totherByKey[v.%s] = i\n", keyField))
					g.buf.WriteString("\t}\n")
					g.buf.WriteString(fmt.Sprintf("\tfor _, v := range t.%s {\n", f.Name))
					g.buf.WriteString(fmt.Sprintf("\t\tif _, ok := otherByKey[v.%s]; !ok {\n", keyField))
					g.buf.WriteString("\t\t\tp.Operations = append(p.Operations, " + pkgPrefix + "Operation{\n")
					g.buf.WriteString("\t\t\t\tKind: " + pkgPrefix + "OpRemove,\n")
					g.buf.WriteString(fmt.Sprintf("\t\t\t\tPath: fmt.Sprintf(\"/%s/%%v\", v.%s),\n", f.JSONName, keyField))
					g.buf.WriteString("\t\t\t\tOld:  v,\n")
					g.buf.WriteString("\t\t\t})\n")
					g.buf.WriteString("\t\t}\n")
					g.buf.WriteString("\t}\n")
					g.buf.WriteString(fmt.Sprintf("\ttByKey := make(map[any]int)\n"))
					g.buf.WriteString(fmt.Sprintf("\tfor i, v := range t.%s {\n", f.Name))
					g.buf.WriteString(fmt.Sprintf("\t\ttByKey[v.%s] = i\n", keyField))
					g.buf.WriteString("\t}\n")
					g.buf.WriteString(fmt.Sprintf("\tfor _, v := range other.%s {\n", f.Name))
					g.buf.WriteString(fmt.Sprintf("\t\tif _, ok := tByKey[v.%s]; !ok {\n", keyField))
					g.buf.WriteString("\t\t\tp.Operations = append(p.Operations, " + pkgPrefix + "Operation{\n")
					g.buf.WriteString("\t\t\t\tKind: " + pkgPrefix + "OpAdd,\n")
					g.buf.WriteString(fmt.Sprintf("\t\t\t\tPath: fmt.Sprintf(\"/%s/%%v\", v.%s),\n", f.JSONName, keyField))
					g.buf.WriteString("\t\t\t\tNew:  v,\n")
					g.buf.WriteString("\t\t\t})\n")
					g.buf.WriteString("\t\t}\n")
					g.buf.WriteString("\t}\n")
				} else {
					g.buf.WriteString(fmt.Sprintf("\tif len(t.%s) != len(other.%s) {\n", f.Name, f.Name))
					g.buf.WriteString("\t\tp.Operations = append(p.Operations, " + pkgPrefix + "Operation{\n")
					g.buf.WriteString("\t\t\tKind: " + pkgPrefix + "OpReplace,\n")
					g.buf.WriteString(fmt.Sprintf("\t\t\tPath: \"/%s\",\n", f.JSONName))
					g.buf.WriteString(fmt.Sprintf("\t\t\tOld:  t.%s,\n", f.Name))
					g.buf.WriteString(fmt.Sprintf("\t\t\tNew:  other.%s,\n", f.Name))
					g.buf.WriteString("\t\t})\n")
					g.buf.WriteString("\t} else {\n")
					g.buf.WriteString(fmt.Sprintf("\t\tfor i := range t.%s {\n", f.Name))
					g.buf.WriteString(fmt.Sprintf("\t\t\tif t.%s[i] != other.%s[i] {\n", f.Name, f.Name))
					g.buf.WriteString("\t\t\t\tp.Operations = append(p.Operations, " + pkgPrefix + "Operation{\n")
					g.buf.WriteString("\t\t\t\t\tKind: " + pkgPrefix + "OpReplace,\n")
					g.buf.WriteString(fmt.Sprintf("\t\t\t\t\tPath: fmt.Sprintf(\"/%s/%%d\", i),\n", f.JSONName))
					g.buf.WriteString(fmt.Sprintf("\t\t\t\t\tOld:  t.%s[i],\n", f.Name))
					g.buf.WriteString(fmt.Sprintf("\t\t\t\t\tNew:  other.%s[i],\n", f.Name))
					g.buf.WriteString("\t\t\t\t})\n")
					g.buf.WriteString("\t\t\t}\n")
					g.buf.WriteString("\t\t}\n")
					g.buf.WriteString("\t}\n")
				}
			}
		} else {
			g.buf.WriteString(fmt.Sprintf("\tif t.%s != other.%s {\n", f.Name, f.Name))
			g.buf.WriteString("\t\tp.Operations = append(p.Operations, " + pkgPrefix + "Operation{\n")
			g.buf.WriteString("\t\t\tKind: " + pkgPrefix + "OpReplace,\n")
			g.buf.WriteString(fmt.Sprintf("\t\t\tPath: \"/%s\",\n", f.JSONName))
			g.buf.WriteString(fmt.Sprintf("\t\t\tOld:  t.%s,\n", f.Name))
			g.buf.WriteString(fmt.Sprintf("\t\t\tNew:  other.%s,\n", f.Name))
			g.buf.WriteString("\t\t})\n")
			g.buf.WriteString("\t}\n")
		}
	}

	g.buf.WriteString("\treturn p\n")
	g.buf.WriteString("}\n\n")

	// evaluateCondition implementation
	g.buf.WriteString(fmt.Sprintf("func (t *%s) evaluateCondition(c %sCondition) (bool, error) {\n", typeName, pkgPrefix))
	g.buf.WriteString("\tswitch c.Op {\n")
	g.buf.WriteString("\tcase \"and\":\n")
	g.buf.WriteString("\t\tfor _, sub := range c.Apply {\n")
	g.buf.WriteString("\t\t\tok, err := t.evaluateCondition(*sub)\n")
	g.buf.WriteString("\t\t\tif err != nil || !ok { return false, err }\n")
	g.buf.WriteString("\t\t}\n")
	g.buf.WriteString("\t\treturn true, nil\n")
	g.buf.WriteString("\tcase \"or\":\n")
	g.buf.WriteString("\t\tfor _, sub := range c.Apply {\n")
	g.buf.WriteString("\t\t\tok, err := t.evaluateCondition(*sub)\n")
	g.buf.WriteString("\t\t\tif err == nil && ok { return true, nil }\n")
	g.buf.WriteString("\t\t}\n")
	g.buf.WriteString("\t\treturn false, nil\n")
	g.buf.WriteString("\tcase \"not\":\n")
	g.buf.WriteString("\t\tif len(c.Apply) > 0 {\n")
	g.buf.WriteString("\t\t\tok, err := t.evaluateCondition(*c.Apply[0])\n")
	g.buf.WriteString("\t\t\tif err != nil { return false, err }\n")
	g.buf.WriteString("\t\t\treturn !ok, nil\n")
	g.buf.WriteString("\t\t}\n")
	g.buf.WriteString("\t\treturn true, nil\n")
	g.buf.WriteString("\t}\n\n")
	g.buf.WriteString("\tswitch c.Path {\n")
	for _, f := range fields {
		if f.Ignore {
			continue
		}
		if f.IsStruct || f.IsCollection || f.IsText {
			continue
		}
		if f.JSONName != f.Name {
			g.buf.WriteString(fmt.Sprintf("\tcase \"/%s\", \"/%s\":\n", f.JSONName, f.Name))
		} else {
			g.buf.WriteString(fmt.Sprintf("\tcase \"/%s\":\n", f.Name))
		}
		g.buf.WriteString("\t\tswitch c.Op {\n")
		g.buf.WriteString(fmt.Sprintf("\t\tcase \"==\": return t.%s == c.Value.(%s), nil\n", f.Name, f.Type))
		g.buf.WriteString(fmt.Sprintf("\t\tcase \"!=\": return t.%s != c.Value.(%s), nil\n", f.Name, f.Type))
		g.buf.WriteString(fmt.Sprintf("\t\tcase \"log\": fmt.Printf(\"DEEP LOG CONDITION: %%v (at %%s, value: %%v)\\n\", c.Value, c.Path, t.%s); return true, nil\n", f.Name))
		g.buf.WriteString(fmt.Sprintf("\t\tcase \"matches\": return regexp.MatchString(c.Value.(string), fmt.Sprintf(\"%%v\", t.%s))\n", f.Name))
		g.buf.WriteString(fmt.Sprintf("\t\tcase \"type\": return checkType(t.%s, c.Value.(string)), nil\n", f.Name))
		g.buf.WriteString("\t\t}\n")
	}
	g.buf.WriteString("\t}\n")
	g.buf.WriteString("\treturn false, fmt.Errorf(\"unsupported condition path or op: %s\", c.Path)\n")
	g.buf.WriteString("}\n\n")

	// Equal implementation
	g.buf.WriteString(fmt.Sprintf("// Equal returns true if t and other are deeply equal.\n"))
	g.buf.WriteString(fmt.Sprintf("func (t *%s) Equal(other *%s) bool {\n", typeName, typeName))
	for _, f := range fields {
		if f.Ignore {
			continue
		}
		isPtr := strings.HasPrefix(f.Type, "*")
		selfArg := "(&t." + f.Name + ")"
		otherArg := "(&other." + f.Name + ")"
		if isPtr {
			selfArg = "t." + f.Name
			otherArg = "other." + f.Name
		}
		if f.IsStruct {
			if isPtr {
				g.buf.WriteString(fmt.Sprintf("\tif (%s == nil) != (%s == nil) { return false }\n", selfArg, otherArg))
				g.buf.WriteString(fmt.Sprintf("\tif %s != nil && !%s.Equal(%s) { return false }\n", selfArg, selfArg, otherArg))
			} else {
				g.buf.WriteString(fmt.Sprintf("\tif !%s.Equal(%s) { return false }\n", selfArg, otherArg))
			}
		} else if f.IsText {
			g.buf.WriteString(fmt.Sprintf("\tif len(t.%s) != len(other.%s) { return false }\n", f.Name, f.Name))
			g.buf.WriteString(fmt.Sprintf("\tfor i := range t.%s {\n", f.Name))
			g.buf.WriteString(fmt.Sprintf("\t\tif t.%s[i] != other.%s[i] { return false }\n", f.Name, f.Name))
			g.buf.WriteString("\t}\n")
		} else if f.IsCollection {
			g.buf.WriteString(fmt.Sprintf("\tif len(t.%s) != len(other.%s) { return false }\n", f.Name, f.Name))
		} else {
			g.buf.WriteString(fmt.Sprintf("\tif t.%s != other.%s { return false }\n", f.Name, f.Name))
		}
	}
	g.buf.WriteString("\treturn true\n")
	g.buf.WriteString("}\n\n")

	// Copy implementation
	g.buf.WriteString(fmt.Sprintf("// Copy returns a deep copy of t.\n"))
	g.buf.WriteString(fmt.Sprintf("func (t *%s) Copy() *%s {\n", typeName, typeName))
	g.buf.WriteString(fmt.Sprintf("\tres := &%s{\n", typeName))
	for _, f := range fields {
		if f.Ignore {
			continue
		}
		if f.IsStruct {
			// handled below due to nil check
		} else if f.IsText {
			g.buf.WriteString(fmt.Sprintf("\t\t%s: append(%s(nil), t.%s...),\n", f.Name, f.Type, f.Name))
		} else if f.IsCollection {
			if strings.HasPrefix(f.Type, "[]") {
				g.buf.WriteString(fmt.Sprintf("\t\t%s: append(%s(nil), t.%s...),\n", f.Name, f.Type, f.Name))
			}
		} else {
			g.buf.WriteString(fmt.Sprintf("\t\t%s: t.%s,\n", f.Name, f.Name))
		}
	}
	g.buf.WriteString("\t}\n")

	for _, f := range fields {
		if f.Ignore {
			continue
		}
		if f.IsStruct {
			isPtr := strings.HasPrefix(f.Type, "*")
			selfArg := "(&t." + f.Name + ")"
			if isPtr {
				selfArg = "t." + f.Name
			}
			if isPtr {
				g.buf.WriteString(fmt.Sprintf("\tif %s != nil {\n", selfArg))
				g.buf.WriteString(fmt.Sprintf("\t\tres.%s = %s.Copy()\n", f.Name, selfArg))
				g.buf.WriteString("\t}\n")
			} else {
				g.buf.WriteString(fmt.Sprintf("\tres.%s = *%s.Copy()\n", f.Name, selfArg))
			}
		}
		if f.IsCollection && strings.HasPrefix(f.Type, "map[") {
			g.buf.WriteString(fmt.Sprintf("\tif t.%s != nil {\n", f.Name))
			g.buf.WriteString(fmt.Sprintf("\t\tres.%s = make(%s)\n", f.Name, f.Type))
			g.buf.WriteString(fmt.Sprintf("\t\tfor k, v := range t.%s {\n", f.Name))
			valType := f.Type[strings.Index(f.Type, "]")+1:]
			if strings.HasPrefix(valType, "*") {
				g.buf.WriteString(fmt.Sprintf("\t\t\tif v != nil { res.%s[k] = v.Copy() }\n", f.Name))
			} else {
				g.buf.WriteString(fmt.Sprintf("\t\tres.%s[k] = v\n", f.Name))
			}
			g.buf.WriteString("\t\t}\n")
			g.buf.WriteString("\t}\n")
		}
	}

	g.buf.WriteString("\treturn res\n")
	g.buf.WriteString("}\n")
}

type FieldInfo struct {
	Name         string
	JSONName     string
	Type         string
	IsStruct     bool
	IsCollection bool
	IsText       bool
	KeyField     string
	Ignore       bool
	ReadOnly     bool
	Atomic       bool
}

func main() {
	flag.Parse()
	if len(*typeNames) == 0 {
		log.Fatal("type flag required")
	}

	dir := "."
	if len(flag.Args()) > 0 {
		dir = flag.Args()[0]
	}

	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, nil, 0)
	if err != nil {
		log.Fatal(err)
	}

	var g *Generator

	for pkgName, pkg := range pkgs {
		if strings.HasSuffix(pkgName, "_test") {
			continue
		}

		if g == nil {
			g = &Generator{
				pkgName:  pkgName,
				typeKeys: make(map[string]string),
			}
		}

		requestedTypes := make(map[string]bool)
		for _, t := range strings.Split(*typeNames, ",") {
			requestedTypes[strings.TrimSpace(t)] = true
		}

		// First pass: find keys and tags
		for _, file := range pkg.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				ts, ok := n.(*ast.TypeSpec)
				if !ok {
					return true
				}
				st, ok := ts.Type.(*ast.StructType)
				if !ok {
					return true
				}
				for _, field := range st.Fields.List {
					if field.Tag != nil {
						tag := strings.Trim(field.Tag.Value, "`")
						if strings.Contains(tag, "deep:\"key\"") {
							if len(field.Names) > 0 {
								g.typeKeys[ts.Name.Name] = field.Names[0].Name
							}
						}
					}
				}
				return true
			})
		}

		// Second pass: generate
		var allFields [][]FieldInfo
		var allTypes []string

		for _, file := range pkg.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				ts, ok := n.(*ast.TypeSpec)
				if !ok || !requestedTypes[ts.Name.Name] {
					return true
				}
				st, ok := ts.Type.(*ast.StructType)
				if !ok {
					return true
				}

				var fields []FieldInfo
				for _, field := range st.Fields.List {
					if len(field.Names) == 0 {
						continue
					}
					name := field.Names[0].Name
					jsonName := name
					var deepIgnore, deepReadOnly, deepAtomic bool

					if field.Tag != nil {
						tagValue := strings.Trim(field.Tag.Value, "`")
						tag := reflect.StructTag(tagValue)
						if jt := tag.Get("json"); jt != "" {
							jsonName = strings.Split(jt, ",")[0]
						}
						dt := tag.Get("deep")
						if dt != "" {
							parts := strings.Split(dt, ",")
							for _, p := range parts {
								p = strings.TrimSpace(p)
								switch p {
								case "-":
									deepIgnore = true
								case "readonly":
									deepReadOnly = true
								case "atomic":
									deepAtomic = true
								}
							}
						}
					}

					typeName := "unknown"
					isStruct := false
					isCollection := false
					isText := false

					switch typ := field.Type.(type) {
					case *ast.Ident:
						typeName = typ.Name
						if typeName == "Text" {
							isText = true
						} else if len(typeName) > 0 && typeName[0] >= 'A' && typeName[0] <= 'Z' {
							switch typeName {
							case "String", "Int", "Bool", "Float64":
							default:
								isStruct = true
							}
						}
					case *ast.StarExpr:
						if ident, ok := typ.X.(*ast.Ident); ok {
							typeName = "*" + ident.Name
							isStruct = true
						}
					case *ast.SelectorExpr:
						if ident, ok := typ.X.(*ast.Ident); ok && ident.Name == "deep" {
							if typ.Sel.Name == "Text" {
								isText = true
								typeName = "v5.Text"
							}
						}
					case *ast.ArrayType:
						isCollection = true
						if ident, ok := typ.Elt.(*ast.Ident); ok {
							typeName = "[]" + ident.Name
						} else if star, ok := typ.Elt.(*ast.StarExpr); ok {
							if ident, ok := star.X.(*ast.Ident); ok {
								typeName = "[]*" + ident.Name
							}
						} else {
							typeName = "[]any"
						}
					case *ast.MapType:
						isCollection = true
						keyName := "any"
						valName := "any"
						if ident, ok := typ.Key.(*ast.Ident); ok {
							keyName = ident.Name
						}
						switch vtyp := typ.Value.(type) {
						case *ast.Ident:
							valName = vtyp.Name
						case *ast.StarExpr:
							if ident, ok := vtyp.X.(*ast.Ident); ok {
								valName = "*" + ident.Name
							}
						}
						typeName = fmt.Sprintf("map[%s]%s", keyName, valName)
					}

					fields = append(fields, FieldInfo{
						Name:         name,
						JSONName:     jsonName,
						Type:         typeName,
						IsStruct:     isStruct,
						IsCollection: isCollection,
						IsText:       isText,
						Ignore:       deepIgnore,
						ReadOnly:     deepReadOnly,
						Atomic:       deepAtomic,
					})
				}

				allTypes = append(allTypes, ts.Name.Name)
				allFields = append(allFields, fields)
				return false
			})
		}

		if len(allTypes) > 0 {
			var combinedFields []FieldInfo
			for _, fs := range allFields {
				combinedFields = append(combinedFields, fs...)
			}
			g.header(combinedFields)
			for i := range allTypes {
				g.generate(allTypes[i], allFields[i])
			}
		}
	}

	if g != nil {
		if g.pkgName != "deep" {
			// helper for map contains check
			g.buf.WriteString("\nfunc contains[M ~map[K]V, K comparable, V any](m M, k K) bool {\n")
			g.buf.WriteString("\t_, ok := m[k]\n")
			g.buf.WriteString("\treturn ok\n")
			g.buf.WriteString("}\n")

			g.buf.WriteString("\nfunc checkType(v any, typeName string) bool {\n")
			g.buf.WriteString("\tswitch typeName {\n")
			g.buf.WriteString("\tcase \"string\":\n")
			g.buf.WriteString("\t\t_, ok := v.(string)\n")
			g.buf.WriteString("\t\treturn ok\n")
			g.buf.WriteString("\tcase \"number\":\n")
			g.buf.WriteString("\t\tswitch v.(type) {\n")
			g.buf.WriteString("\t\tcase int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64:\n")
			g.buf.WriteString("\t\t\treturn true\n")
			g.buf.WriteString("\t\t}\n")
			g.buf.WriteString("\tcase \"boolean\":\n")
			g.buf.WriteString("\t\t_, ok := v.(bool)\n")
			g.buf.WriteString("\t\treturn ok\n")
			g.buf.WriteString("\tcase \"object\":\n")
			g.buf.WriteString("\t\trv := reflect.ValueOf(v)\n")
			g.buf.WriteString("\t\treturn rv.Kind() == reflect.Struct || rv.Kind() == reflect.Map\n")
			g.buf.WriteString("\tcase \"array\":\n")
			g.buf.WriteString("\t\trv := reflect.ValueOf(v)\n")
			g.buf.WriteString("\t\treturn rv.Kind() == reflect.Slice || rv.Kind() == reflect.Array\n")
			g.buf.WriteString("\tcase \"null\":\n")
			g.buf.WriteString("\t\tif v == nil { return true }\n")
			g.buf.WriteString("\t\trv := reflect.ValueOf(v)\n")
			g.buf.WriteString("\t\treturn (rv.Kind() == reflect.Pointer || rv.Kind() == reflect.Interface || rv.Kind() == reflect.Slice || rv.Kind() == reflect.Map) && rv.IsNil()\n")
			g.buf.WriteString("\t}\n")
			g.buf.WriteString("\treturn false\n")
			g.buf.WriteString("}\n")
		}

		fmt.Print(g.buf.String())
	}
}
